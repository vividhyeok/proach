<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Proach Web</title>
  <style>
    :root {
      font-family: "Segoe UI", sans-serif;
      color: #1e2433;
      background: #f6f7fb;
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background: #1f3fb4;
      color: #fff;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
    }
    header input, header button {
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
    }
    header input {
      min-width: 200px;
    }
    header button {
      background: #ffd24d;
      color: #1e2433;
      cursor: pointer;
      border: 1px solid #d6a500;
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1fr 1fr;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }
    section {
      background: #fff;
      border: 1px solid #e6e8ef;
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    h2 {
      margin: 0;
      font-size: 16px;
    }
    .list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .list button, .pill {
      background: #f3f5fb;
      border: 1px solid #d8deec;
      border-radius: 8px;
      padding: 10px 12px;
      text-align: left;
      cursor: pointer;
      transition: border 0.1s ease, background 0.1s ease;
    }
    .list button.active {
      border-color: #1f3fb4;
      background: #e8edff;
    }
    textarea, input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #d8deec;
      border-radius: 8px;
      font-size: 14px;
      resize: vertical;
    }
    label span {
      display: block;
      font-size: 13px;
      color: #566;
      margin-bottom: 4px;
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .primary {
      background: #1f3fb4;
      color: #fff;
      border: 1px solid #1f3fb4;
    }
    .danger {
      background: #ffe8e6;
      color: #a11;
      border: 1px solid #ffb3ae;
    }
    .muted {
      background: #f3f5fb;
      color: #2d3445;
      border: 1px solid #d8deec;
    }
    .status {
      min-height: 22px;
      font-size: 13px;
      color: #364152;
    }
    pre {
      background: #0b1224;
      color: #e8edf7;
      padding: 10px;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <header>
    <h1>Proach Web</h1>
    <div class="actions">
      <input id="session-title" type="text" placeholder="세션 제목" />
      <input id="session-slides" type="text" placeholder="슬라이드 제목(쉼표로 구분)" />
      <button id="create-session" class="primary">새 세션</button>
      <select id="session-picker" class="muted"></select>
      <button id="load-session" class="muted">불러오기</button>
    </div>
  </header>
  <main>
    <section>
      <h2>슬라이드</h2>
      <div class="list" id="slides"></div>
      <div class="actions">
        <input id="new-slide-title" type="text" placeholder="새 슬라이드 제목" />
        <button id="add-slide" class="primary">추가</button>
        <button id="delete-slide" class="danger">삭제</button>
      </div>
      <label>
        <span>제목</span>
        <input id="slide-title" type="text" />
      </label>
      <label>
        <span>노트 / 키워드 (줄바꿈으로 분리)</span>
        <textarea id="slide-notes" rows="6"></textarea>
      </label>
      <div class="status" id="left-status"></div>
    </section>
    <section>
      <h2>녹음</h2>
      <div class="actions">
        <button id="start-record" class="primary">녹음 시작</button>
        <button id="stop-record" class="muted" disabled>정지</button>
      </div>
      <div class="status" id="record-status">마이크 권한을 허용한 뒤 녹음을 시작하세요.</div>
      <div>
        <h3>선택된 슬라이드의 테이크</h3>
        <div class="list" id="takes"></div>
      </div>
    </section>
    <section>
      <h2>전사 · 분석</h2>
      <div class="actions">
        <button id="transcribe" class="primary">이 테이크 전사</button>
        <button id="analyze" class="muted">분석만 실행</button>
      </div>
      <div>
        <h3>전사 결과</h3>
        <pre id="transcript"></pre>
      </div>
      <div>
        <h3>분석</h3>
        <pre id="analysis"></pre>
      </div>
      <div class="status" id="right-status"></div>
    </section>
  </main>
  <script>
    let session = null;
    let currentSlideId = null;
    let currentTakeId = null;
    let recorder = null;
    let mediaStream = null;
    let chunks = [];

    const slidesEl = document.getElementById('slides');
    const takesEl = document.getElementById('takes');
    const recordStatus = document.getElementById('record-status');
    const leftStatus = document.getElementById('left-status');
    const rightStatus = document.getElementById('right-status');

    async function fetchSession() {
      const res = await fetch('/api/session');
      session = await res.json();
      renderSessionPicker();
      renderSlides();
    }

    async function renderSessionPicker() {
      const picker = document.getElementById('session-picker');
      const res = await fetch('/api/sessions');
      const data = await res.json();
      picker.innerHTML = '';
      data.sessions.forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        if (id === data.active_session) opt.selected = true;
        picker.appendChild(opt);
      });
    }

    function renderSlides() {
      slidesEl.innerHTML = '';
      session.slides.forEach(slide => {
        const btn = document.createElement('button');
        btn.textContent = `${String(slide.id).padStart(2, '0')} · ${slide.title}`;
        btn.dataset.slideId = slide.id;
        btn.classList.toggle('active', slide.id === currentSlideId);
        btn.onclick = () => selectSlide(slide.id);
        slidesEl.appendChild(btn);
      });
      if (!currentSlideId && session.slides.length) {
        selectSlide(session.slides[0].id);
      } else if (!session.slides.length) {
        selectSlide(null);
      }
    }

    function selectSlide(slideId) {
      currentSlideId = slideId;
      currentTakeId = null;
      document.querySelectorAll('#slides button').forEach(btn => {
        btn.classList.toggle('active', Number(btn.dataset.slideId) === slideId);
      });
      const slide = session.slides.find(s => s.id === slideId);
      document.getElementById('slide-title').value = slide ? slide.title : '';
      document.getElementById('slide-notes').value = slide ? slide.notes : '';
      renderTakes();
    }

    function renderTakes() {
      takesEl.innerHTML = '';
      if (!currentSlideId) return;
      const takes = session.takes_by_slide[currentSlideId] || [];
      takes.forEach(take => {
        const btn = document.createElement('button');
        btn.textContent = `Take ${take.id} • ${take.duration_sec.toFixed(1)}s`;
        btn.dataset.takeId = take.id;
        btn.classList.toggle('active', take.id === currentTakeId);
        btn.onclick = () => selectTake(take.id);
        takesEl.appendChild(btn);
      });
      if (takes.length && !currentTakeId) {
        selectTake(takes[takes.length - 1].id);
      }
      if (!takes.length) {
        document.getElementById('transcript').textContent = '';
        document.getElementById('analysis').textContent = '';
      }
    }

    function selectTake(takeId) {
      currentTakeId = takeId;
      document.querySelectorAll('#takes button').forEach(btn => {
        btn.classList.toggle('active', Number(btn.dataset.takeId) === takeId);
      });
      const take = (session.takes_by_slide[currentSlideId] || []).find(t => t.id === takeId);
      document.getElementById('transcript').textContent = take?.transcript_text || '';
      document.getElementById('analysis').textContent = '';
    }

    async function createSession() {
      const title = document.getElementById('session-title').value || 'My Presentation';
      const slidesRaw = document.getElementById('session-slides').value;
      const slides = slidesRaw.split(',').map(s => s.trim()).filter(Boolean);
      const res = await fetch('/api/sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, slides })
      });
      session = await res.json();
      currentSlideId = null;
      await renderSessionPicker();
      renderSlides();
      leftStatus.textContent = `새 세션 생성: ${session.id}`;
    }

    async function loadSession() {
      const picker = document.getElementById('session-picker');
      const id = picker.value;
      if (!id) return;
      const res = await fetch(`/api/sessions/${id}/open`, { method: 'POST' });
      session = await res.json();
      currentSlideId = null;
      renderSlides();
      leftStatus.textContent = `${id} 세션을 불러왔습니다.`;
    }

    async function saveSlide(field) {
      if (!currentSlideId) return;
      const slide = session.slides.find(s => s.id === currentSlideId);
      const payload = { title: slide.title, notes: slide.notes };
      payload[field] = document.getElementById(field === 'title' ? 'slide-title' : 'slide-notes').value;
      slide.title = payload.title;
      slide.notes = payload.notes;
      await fetch(`/api/slides/${currentSlideId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      renderSlides();
      leftStatus.textContent = '슬라이드 정보를 저장했습니다.';
    }

    async function addSlide() {
      const title = document.getElementById('new-slide-title').value || 'New slide';
      const res = await fetch('/api/slides', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title })
      });
      const slide = await res.json();
      session.slides.push(slide);
      session.takes_by_slide[slide.id] = [];
      currentSlideId = slide.id;
      renderSlides();
      renderTakes();
      document.getElementById('new-slide-title').value = '';
    }

    async function deleteSlide() {
      if (!currentSlideId) return;
      if (!confirm('이 슬라이드와 테이크를 삭제할까요?')) return;
      await fetch(`/api/slides/${currentSlideId}`, { method: 'DELETE' });
      session.slides = session.slides.filter(s => s.id !== currentSlideId);
      delete session.takes_by_slide[currentSlideId];
      currentSlideId = null;
      renderSlides();
      renderTakes();
    }

    function encodeWavFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const format = 1; // PCM
      const bitsPerSample = 16;
      const samples = audioBuffer.length;
      const blockAlign = numChannels * bitsPerSample / 8;
      const buffer = new ArrayBuffer(44 + samples * blockAlign);
      const view = new DataView(buffer);

      function writeString(offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      writeString(0, 'RIFF');
      view.setUint32(4, 36 + samples * blockAlign, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true); // Subchunk1Size
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitsPerSample, true);
      writeString(36, 'data');
      view.setUint32(40, samples * blockAlign, true);

      let offset = 44;
      for (let i = 0; i < samples; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = audioBuffer.getChannelData(ch)[i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }
      }
      return new Blob([buffer], { type: 'audio/wav' });
    }

    async function startRecording() {
      if (!currentSlideId) {
        recordStatus.textContent = '슬라이드를 먼저 선택하세요.';
        return;
      }
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorder = new MediaRecorder(mediaStream);
      chunks = [];
      recorder.ondataavailable = e => chunks.push(e.data);
      recorder.onstop = () => mediaStream.getTracks().forEach(t => t.stop());
      recorder.start();
      recordStatus.textContent = '녹음 중...';
      document.getElementById('start-record').disabled = true;
      document.getElementById('stop-record').disabled = false;
    }

    async function stopRecording() {
      return new Promise(resolve => {
        recorder.onstop = async () => {
          mediaStream.getTracks().forEach(t => t.stop());
          const rawBlob = new Blob(chunks, { type: 'audio/webm' });
          const arrayBuffer = await rawBlob.arrayBuffer();
          const audioCtx = new AudioContext();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          const wavBlob = encodeWavFromAudioBuffer(audioBuffer);
          await uploadTake(wavBlob, audioBuffer.duration);
          document.getElementById('start-record').disabled = false;
          document.getElementById('stop-record').disabled = true;
          recordStatus.textContent = '녹음을 저장했습니다.';
          resolve();
        };
        recorder.stop();
      });
    }

    async function uploadTake(blob, duration) {
      const form = new FormData();
      form.append('audio', blob, 'take.wav');
      form.append('duration', duration);
      const res = await fetch(`/api/slides/${currentSlideId}/takes`, {
        method: 'POST',
        body: form
      });
      const take = await res.json();
      const list = session.takes_by_slide[currentSlideId] || [];
      list.push(take);
      session.takes_by_slide[currentSlideId] = list;
      renderTakes();
    }

    async function transcribe() {
      if (!currentSlideId || !currentTakeId) {
        rightStatus.textContent = '테이크를 선택하세요.';
        return;
      }
      rightStatus.textContent = '전사 중...';
      const res = await fetch(`/api/slides/${currentSlideId}/takes/${currentTakeId}/transcribe`, { method: 'POST' });
      if (!res.ok) {
        rightStatus.textContent = '전사 실패: API 키를 확인하세요.';
        return;
      }
      const data = await res.json();
      const take = (session.takes_by_slide[currentSlideId] || []).find(t => t.id === currentTakeId);
      take.transcript_text = data.text;
      document.getElementById('transcript').textContent = data.text || '';
      rightStatus.textContent = '전사 완료';
      await analyze();
    }

    async function analyze() {
      if (!currentSlideId || !currentTakeId) {
        rightStatus.textContent = '테이크를 선택하세요.';
        return;
      }
      const res = await fetch(`/api/slides/${currentSlideId}/takes/${currentTakeId}/analysis`);
      const data = await res.json();
      document.getElementById('analysis').textContent = data.summary || '';
      rightStatus.textContent = '분석 완료';
    }

    document.getElementById('create-session').onclick = createSession;
    document.getElementById('load-session').onclick = loadSession;
    document.getElementById('slide-title').onchange = () => saveSlide('title');
    document.getElementById('slide-notes').onchange = () => saveSlide('notes');
    document.getElementById('add-slide').onclick = addSlide;
    document.getElementById('delete-slide').onclick = deleteSlide;
    document.getElementById('start-record').onclick = startRecording;
    document.getElementById('stop-record').onclick = stopRecording;
    document.getElementById('transcribe').onclick = transcribe;
    document.getElementById('analyze').onclick = analyze;

    fetchSession();
  </script>
</body>
</html>
